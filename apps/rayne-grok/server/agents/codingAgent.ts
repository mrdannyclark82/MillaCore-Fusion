import { Agent } from './base';
import { AgentTask } from './taskStorage';
import {
  createSandbox,
  addFeatureToSandbox,
  testFeature,
  evaluateSandboxReadiness,
  markSandboxForMerge,
  type SandboxEnvironment,
  type SandboxFeature,
} from '../sandboxEnvironmentService';
import { createPRForSandbox } from '../automatedPRService';
import {
  analyzeCodeForIssues,
  type SecurityIssue,
  type PerformanceIssue,
  type CodeQualityIssue,
} from '../codeAnalysisService';

export interface IssueIdentification {
  issueType: 'bug' | 'enhancement' | 'security' | 'performance';
  description: string;
  affectedFiles: string[];
  severity: 'low' | 'medium' | 'high' | 'critical';
}

export interface CodeFix {
  description: string;
  files: string[];
  changes: string;
}

class CodingAgent implements Agent {
  name = 'coding';
  description = 'An agent that can write and understand code, perform automated bug fixes, and create pull requests.';

  async execute(task: string): Promise<string> {
    console.log(`CodingAgent received task: ${task}`);
    // In the future, this could be a call to a code generation model
    return `I have received the coding task: '${task}'. I will work on it.`;
  }

  /**
   * Full automated fix lifecycle:
   * 1. Identify documented issues
   * 2. Generate code fix
   * 3. Execute fix in sandbox for testing
   * 4. Create PR upon successful verification
   */
  async performAutomatedFixLifecycle(params: {
    repositoryPath: string;
    issueSource?: 'error_log' | 'code_analysis' | 'manual';
  }): Promise<{
    success: boolean;
    sandboxId?: string;
    prUrl?: string;
    message: string;
  }> {
    try {
      console.log('Starting automated fix lifecycle...');

      // Step 1: Identify issues from code analysis
      const issues = await this.identifyIssues(params.repositoryPath);
      if (issues.length === 0) {
        return {
          success: false,
          message: 'No issues identified for automated fixing',
        };
      }

      console.log(`Identified ${issues.length} issues for fixing`);

      // Select high-priority issue
      const issueToFix = issues.find((i) => i.severity === 'high') || issues[0];

      // Step 2: Generate a code fix
      const fix = await this.generateCodeFix(issueToFix);

      // Step 3: Execute fix in sandbox environment
      const sandbox = await createSandbox({
        name: `fix-${issueToFix.issueType}-${Date.now()}`,
        description: `Automated fix for: ${issueToFix.description}`,
        createdBy: 'milla',
      });

      console.log(`Created sandbox: ${sandbox.id}`);

      // Add feature to sandbox
      const feature = await addFeatureToSandbox(sandbox.id, {
        name: `Fix: ${issueToFix.description}`,
        description: fix.description,
        files: fix.files,
      });

      if (!feature) {
        return {
          success: false,
          message: 'Failed to add feature to sandbox',
        };
      }

      // Step 4: Run tests in sandbox
      const testResults = await Promise.all([
        testFeature(sandbox.id, feature.id, 'unit'),
        testFeature(sandbox.id, feature.id, 'integration'),
      ]);

      const allTestsPassed = testResults.every((result) => result.passed);

      if (!allTestsPassed) {
        return {
          success: false,
          sandboxId: sandbox.id,
          message: `Tests failed in sandbox. Feature status: ${feature.status}`,
        };
      }

      // Evaluate sandbox readiness
      const readiness = evaluateSandboxReadiness(sandbox.id);
      if (!readiness.ready) {
        return {
          success: false,
          sandboxId: sandbox.id,
          message: `Sandbox not ready for merge: ${readiness.reasons.join(', ')}`,
        };
      }

      // Mark sandbox for merge
      await markSandboxForMerge(sandbox.id);

      // Step 5: Create PR via automated PR service
      const prRequest = await createPRForSandbox({
        sandboxId: sandbox.id,
        title: `Automated fix: ${issueToFix.description}`,
        description: `## Automated Code Fix\n\n**Issue Type:** ${issueToFix.issueType}\n**Severity:** ${issueToFix.severity}\n\n${fix.description}\n\n**Affected Files:**\n${fix.files.map((f) => `- ${f}`).join('\n')}\n\n**Test Results:**\nâœ… All tests passed\n\nThis PR was automatically generated by the CodingAgent.`,
        branch: sandbox.branchName,
        files: fix.files,
      });

      console.log(`Created PR request: ${prRequest.id}`);

      return {
        success: true,
        sandboxId: sandbox.id,
        prUrl: prRequest.prUrl,
        message: `Successfully created automated fix and PR for: ${issueToFix.description}`,
      };
    } catch (error) {
      console.error('Error in automated fix lifecycle:', error);
      return {
        success: false,
        message: `Error: ${error instanceof Error ? error.message : 'Unknown error'}`,
      };
    }
  }

  /**
   * Identify issues from error logs or code analysis
   */
  private async identifyIssues(
    repositoryPath: string
  ): Promise<IssueIdentification[]> {
    const issues: IssueIdentification[] = [];

    try {
      // For now, we'll use code analysis service to identify issues
      // In the future, this could also parse error logs
      const analysis = await analyzeCodeForIssues({
        repositoryPath,
        focusAreas: ['security', 'performance', 'quality'],
      });

      // Convert security issues
      analysis.securityIssues.forEach((issue: SecurityIssue) => {
        issues.push({
          issueType: 'security',
          description: issue.description,
          affectedFiles: issue.file ? [issue.file] : [],
          severity: issue.severity === 'critical' ? 'critical' : issue.severity,
        });
      });

      // Convert performance issues
      analysis.performanceIssues.forEach((issue: PerformanceIssue) => {
        issues.push({
          issueType: 'performance',
          description: issue.description,
          affectedFiles: issue.file ? [issue.file] : [],
          severity: issue.severity,
        });
      });

      // Convert code quality issues
      analysis.codeQualityIssues.forEach((issue: CodeQualityIssue) => {
        issues.push({
          issueType: 'enhancement',
          description: issue.description,
          affectedFiles: issue.file ? [issue.file] : [],
          severity: 'medium',
        });
      });
    } catch (error) {
      console.error('Error identifying issues:', error);
    }

    return issues;
  }

  /**
   * Generate a code fix for an identified issue
   */
  private async generateCodeFix(issue: IssueIdentification): Promise<CodeFix> {
    // This is a placeholder. In a production system, this would use an AI model
    // to generate actual code fixes based on the issue description
    return {
      description: `Fix for ${issue.issueType}: ${issue.description}`,
      files: issue.affectedFiles,
      changes: `Automated fix applied to address ${issue.severity} severity ${issue.issueType} issue`,
    };
  }

  /**
   * Handle agent tasks (implements AgentDefinition interface)
   */
  async handleTask(task: AgentTask): Promise<any> {
    console.log(`CodingAgent handling task: ${task.action}`);

    switch (task.action) {
      case 'automated_fix':
        return await this.performAutomatedFixLifecycle({
          repositoryPath: task.payload?.repositoryPath || process.cwd(),
          issueSource: task.payload?.issueSource || 'code_analysis',
        });

      case 'analyze_code':
        return await this.identifyIssues(
          task.payload?.repositoryPath || process.cwd()
        );

      case 'generate_fix':
        return await this.generateCodeFix(task.payload?.issue);

      default:
        return {
          success: false,
          message: `Unknown action: ${task.action}`,
        };
    }
  }
}

export const codingAgent = new CodingAgent();

// Register the coding agent with the registry for task-based operations
import { registerAgent } from './registry';

registerAgent({
  name: 'CodingAgent',
  description: 'Automated code analysis, bug fixing, and PR creation agent',
  handleTask: async (task: AgentTask) => {
    return await codingAgent.handleTask(task);
  },
});
