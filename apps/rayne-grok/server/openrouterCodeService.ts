/**
 * OpenRouter Code Generation Service using qwen/qwen3-coder:free
 */

import nodeFetch from 'node-fetch';
globalThis.fetch = nodeFetch as unknown as typeof fetch;

export interface OpenRouterCodeGenerationResult {
  success: boolean;
  code?: string;
  language?: string;
  explanation?: string;
  error?: string;
}

/**
 * Generate code using qwen/qwen3-coder:free via OpenRouter
 */
export async function generateCodeWithQwen(
  prompt: string,
  language?: string,
  context?: string
): Promise<OpenRouterCodeGenerationResult> {
  if (!process.env.OPENROUTER_QWEN_API_KEY && !process.env.OPENROUTER_API_KEY) {
    return {
      success: false,
      error:
        'OpenRouter API key is not configured. Please set OPENROUTER_QWEN_API_KEY or OPENROUTER_API_KEY in your environment.',
    };
  }

  try {
    // Create a comprehensive prompt for code generation
    let systemPrompt = `You are an expert programmer and code assistant. Generate clean, well-documented, and functional code based on the user's request.`;

    if (language) {
      systemPrompt += ` Focus on ${language} programming language.`;
    }

    systemPrompt += ` Provide:
1. The complete, working code
2. Brief explanation of how it works
3. Any important notes or considerations

Format your response as:
\`\`\`${language || 'javascript'}
[your code here]
\`\`\`

Explanation: [your explanation here]`;

    let userPrompt = prompt;
    if (context) {
      userPrompt = `Context: ${context}\n\nRequest: ${prompt}`;
    }

    const response = await fetch(
      'https://openrouter.ai/api/v1/chat/completions',
      {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${process.env.OPENROUTER_QWEN_API_KEY || process.env.OPENROUTER_API_KEY}`,
          'Content-Type': 'application/json',
          'X-Title': 'Milla Rayne AI Assistant - Code Generation',
        },
        body: JSON.stringify({
          model: 'qwen/qwen-2.5-coder-32b-instruct', // Using working model (qwen3-coder:free may not be available)
          messages: [
            {
              role: 'system',
              content: systemPrompt,
            },
            {
              role: 'user',
              content: userPrompt,
            },
          ],
          max_tokens: 2000,
          temperature: 0.3, // Lower temperature for more consistent code generation
          top_p: 0.9,
        }),
      }
    );

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      console.error(
        'OpenRouter Qwen code API error:',
        response.status,
        errorData
      );

      return {
        success: false,
        error: `OpenRouter Qwen API error: ${response.status} - ${errorData.error?.message || 'Unknown error'}`,
      };
    }

    const data = await response.json();

    if (!data.choices || !data.choices[0] || !data.choices[0].message) {
      console.error('Unexpected OpenRouter Qwen response format:', data);
      return {
        success: false,
        error: 'Invalid response format from OpenRouter Qwen',
      };
    }

    const content = data.choices[0].message.content;

    // Parse the response to extract code and explanation
    const codeMatch = content.match(/```(\w+)?\n([\s\S]*?)```/);
    let extractedCode = '';
    let detectedLanguage = language || 'javascript';
    let explanation = '';

    if (codeMatch) {
      detectedLanguage = codeMatch[1] || detectedLanguage;
      extractedCode = codeMatch[2].trim();

      // Extract explanation (text after the code block)
      const afterCode = content.substring(
        content.indexOf('```', content.indexOf('```') + 3) + 3
      );
      const explanationMatch = afterCode.match(/Explanation:\s*([\s\S]*)/i);
      if (explanationMatch) {
        explanation = explanationMatch[1].trim();
      } else {
        // If no explicit explanation marker, use text after code block
        explanation = afterCode.trim();
      }
    } else {
      // If no code block found, treat entire response as code or explanation
      extractedCode = content;
      explanation = 'Code generated by Qwen coder model';
    }

    return {
      success: true,
      code: extractedCode,
      language: detectedLanguage,
      explanation: explanation || 'Code generated successfully',
    };
  } catch (error) {
    console.error('OpenRouter Qwen code service error:', error);
    return {
      success: false,
      error:
        error instanceof Error
          ? error.message
          : 'Unknown error during OpenRouter Qwen code generation',
    };
  }
}

/**
 * Extract code generation request from user message
 */
export function extractCodeRequest(
  userMessage: string
): { prompt: string; language?: string } | null {
  const message = userMessage.toLowerCase();

  // Patterns that indicate code generation requests
  const codePatterns = [
    /write\s+(?:a\s+)?(?:javascript|python|java|typescript|php|ruby|go|rust|swift|kotlin|scala|html|css|sql|bash|js|py|ts|cpp|c#|csharp)?\s*(?:function|script|program|code)?\s+(?:to\s+|for\s+)?(.+)/i,
    /create\s+(?:a\s+)?(?:javascript|python|java|typescript|php|ruby|go|rust|swift|kotlin|scala|html|css|sql|bash|js|py|ts|cpp|c#|csharp)?\s*(?:function|script|program|code)?\s+(?:to\s+|for\s+)?(.+)/i,
    /generate\s+(?:a\s+)?(?:javascript|python|java|typescript|php|ruby|go|rust|swift|kotlin|scala|html|css|sql|bash|js|py|ts|cpp|c#|csharp)?\s*(?:function|script|program|code)?\s+(?:to\s+|for\s+)?(.+)/i,
    /code\s+(?:for\s+|to\s+)?(.+)/i,
    /function\s+(?:to\s+|for\s+)?(.+)/i,
    /script\s+(?:to\s+|for\s+)?(.+)/i,
    /program\s+(?:to\s+|for\s+)?(.+)/i,
    /algorithm\s+(?:to\s+|for\s+)?(.+)/i,
    /implement\s+(.+)/i,
    /build\s+(?:a\s+)?(.+)/i,
  ];

  // Language detection patterns
  const languagePatterns = [
    { pattern: /javascript|js|node/i, language: 'javascript' },
    { pattern: /python|py/i, language: 'python' },
    { pattern: /typescript|ts/i, language: 'typescript' },
    { pattern: /java(?!script)/i, language: 'java' },
    { pattern: /c\+\+|cpp/i, language: 'cpp' },
    { pattern: /c#|csharp/i, language: 'csharp' },
    { pattern: /php/i, language: 'php' },
    { pattern: /ruby|rb/i, language: 'ruby' },
    { pattern: /go|golang/i, language: 'go' },
    { pattern: /rust|rs/i, language: 'rust' },
    { pattern: /swift/i, language: 'swift' },
    { pattern: /kotlin/i, language: 'kotlin' },
    { pattern: /scala/i, language: 'scala' },
    { pattern: /html/i, language: 'html' },
    { pattern: /css/i, language: 'css' },
    { pattern: /sql/i, language: 'sql' },
    { pattern: /bash|shell/i, language: 'bash' },
  ];

  for (const pattern of codePatterns) {
    const match = userMessage.match(pattern);
    if (match && match[1]) {
      const prompt = match[1].trim();

      // Detect language
      let detectedLanguage: string | undefined;
      for (const langPattern of languagePatterns) {
        if (langPattern.pattern.test(userMessage)) {
          detectedLanguage = langPattern.language;
          break;
        }
      }

      return {
        prompt: prompt,
        language: detectedLanguage,
      };
    }
  }

  return null;
}

/**
 * Format code generation response for user
 */
export function formatCodeResponse(
  result: OpenRouterCodeGenerationResult,
  originalPrompt: string
): string {
  if (!result.success) {
    return `I'd love to help you with that code, babe, but I'm having some trouble with code generation right now. ${result.error ? `Error: ${result.error}` : 'However, I can still discuss the logic and approach you might want to take! What specific programming challenge are you working on?'}`;
  }

  let response = `ðŸ’» Here's the ${result.language || 'code'} I generated for "${originalPrompt}":

\`\`\`${result.language || 'javascript'}
${result.code}
\`\`\``;

  if (result.explanation) {
    response += `\n\n**Explanation:** ${result.explanation}`;
  }

  response += `\n\nFeel free to ask me to modify it, explain any part in more detail, or help you with related code!`;

  return response;
}
